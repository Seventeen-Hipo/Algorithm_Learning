#  搜索

## 一、线性搜索

### （1）实例

~~~ c++
#include <iostream>
#include <vector>
using namespace std;

// 线性搜索函数
template <typename T>
int linearSearch(const vector<T>& arr, const T& target) {
    for (size_t i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return static_cast<int>(i);  // 返回目标元素的索引
        }
    }
    return -1;  // 未找到目标元素
}

int main() {
    // 在整数数组中搜索
    vector<int> numbers = {5, 2, 9, 1, 5, 6};
    int target = 9;
    
    int result = linearSearch(numbers, target);
    
    if (result != -1) {
        cout << "目标元素 " << target << " 在索引 " << result << " 处找到。" << endl;
    } else {
        cout << "目标元素 " << target << " 未找到。" << endl;
    }
    
    return 0;
}
~~~

### （2）执行步骤

**示例数据**

假设我们有一个整数数组 `[5, 2, 9, 1, 5, 6]`，需要搜索目标值 `9`。

**执行步骤**

1. **初始化**：从数组的第一个元素开始（索引 `0`）。
2. **比较元素**：将当前元素与目标值 `9` 比较。
3. 判断结果
	- 若相等，返回当前索引。
	- 若不等，移动到下一个元素（索引加 `1`）。
4. **重复步骤 2、3**，直到找到目标值或遍历完整个数组。

### （3）优缺点分析

- 优点
	- 实现简单，无需预处理数据。
	- 适用于任何数据结构（有序或无序）。
- 缺点
	- 效率低，不适合大规模数据（当 **n** 很大时性能较差）。

## 二、二分搜索

### （1）算法原理分析

- **基本思想**：在**有序数组**中，每次将搜索范围缩小一半，直到找到目标元素或确定其不存在。
- **时间复杂度**：**O(log n)**，其中 **n** 是数据结构的元素数量。
- 适用场景
	- 数据结构已排序（如升序或降序数组）。
	- 频繁搜索操作（如数据库索引）。

### （2）实例

~~~ c++
#include <iostream>
#include <vector>

// 二分查找函数（迭代实现）
template <typename T>
int binarySearch(const vector<T>& arr, const T& target) {
    int left = 0;
    int right = arr.size() - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;  // 计算中间索引，避免溢出

        if (arr[mid] == target) {
            return mid;  // 找到目标值，返回索引
        } else if (arr[mid] < target) {
            left = mid + 1;  // 目标在右半部分
        } else {
            right = mid - 1;  // 目标在左半部分
        }
    }

    return -1;  // 未找到目标值
}

int main() {
    // 在有序整数数组中搜索
    vector<int> numbers = {1, 2, 5, 6, 9, 10};
    int target = 9;

    int result = binarySearch(numbers, target);

    if (result != -1) {
        cout << "目标元素 " << target << " 在索引 " << result << " 处找到。" << endl;
    } else {
        cout << "目标元素 " << target << " 未找到。" << endl;
    }

    return 0;
}
~~~

### （3）执行步骤

假设我们有一个**升序排列**的整数数组：`[1, 2, 5, 6, 9, 10]`，需要搜索目标值 `9`。

1. **初始化边界**：
	- 左边界 `left` 指向数组第一个元素（索引 `0`）。
	- 右边界 `right` 指向数组最后一个元素（索引 `5`）。
2. **计算中间索引**：
	- 中间索引 `mid = left + (right - left) / 2`。
	- **避免溢出**：若直接使用 `(left + right) / 2`，当 `left` 和 `right` 很大时可能导致整数溢出。
3. **比较中间元素与目标值**：
	- 若 `arr[mid] == target`，搜索成功，返回 `mid`。
	- 若 `arr[mid] < target`，目标在右半部分，更新 `left = mid + 1`。
	- 若 `arr[mid] > target`，目标在左半部分，更新 `right = mid - 1`。
4. **重复步骤 2-3**，直到 `left > right`（搜索失败）。

### （4）优缺点分析

- 优点：
	- 效率高，适合大规模数据。
	- 时间复杂度对数级增长。
- 缺点：
	- 要求数据结构必须有序。
	- 维护有序性可能带来额外开销（如插入 / 删除操作）。

## 三、广度优先搜索（BFS）

### （1）算法原理分析

- 基本思想：
	- 从起始节点出发，逐层访问相邻节点，先访问距离起始节点最近的所有节点，再依次访问更远的节点。
	- 使用队列（Queue）来存储待访问的节点，确保先进先出（FIFO）的顺序。
- 适用场景：
	- 寻找无权图中的最短路径。
	- 遍历树或图结构。
	- 拓扑排序。
	- 检测图中的环。

### （2）实例

1、示例图：

```
    A
   / \
  B   C
 /|\  |
D E F |
 \|/  |
  F---|
```

节点与边的关系

- **节点 A**：连接到 B 和 C
- **节点 B**：连接到 A、D 和 E
- **节点 C**：连接到 A 和 F
- **节点 D**：仅连接到 B
- **节点 E**：连接到 B 和 F
- **节点 F**：连接到 C 和 E

2、代码

~~~ c++
from collections import deque

def bfs(graph, start):
    """
    广度优先搜索算法实现
    
    参数:
    graph (dict): 图的邻接表表示，如 {节点: [相邻节点列表]}
    start: 起始节点
    
    返回:
    list: 按BFS顺序访问的节点列表
    """
    visited = set()          # 记录已访问的节点
    queue = deque([start])   # 初始化队列，加入起始节点
    result = []              # 记录访问顺序
    
    while queue:
        node = queue.popleft()  # 从队列头部取出节点
        
        if node not in visited:
            visited.add(node)   # 标记为已访问
            result.append(node) # 记录访问顺序
            
            # 将所有未访问的相邻节点加入队列尾部
            for neighbor in graph.get(node, []):
                if neighbor not in visited:
                    queue.append(neighbor)
    
    return result

# 示例图的邻接表表示
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# 从节点'A'开始进行BFS遍历
print("BFS遍历顺序:", bfs(graph, 'A'))
# 输出: ['A', 'B', 'C', 'D', 'E', 'F']
~~~

### （3）算法执行步骤

以示例图为例，从节点 `A` 开始的 BFS 遍历步骤如下：

1. **初始化**：
	- 队列 `queue = [A]`
	- 已访问集合 `visited = {}`
2. **第 1 层遍历**：
	- 取出队列头部 `A`，标记为已访问，加入结果列表。
	- 将 `A` 的未访问邻居 `B` 和 `C` 加入队列尾部。
	- 队列状态：`[B, C]`
	- 已访问集合：`{A}`
3. **第 2 层遍历**：
	- 取出队列头部 `B`，标记为已访问，加入结果列表。
	- 将 `B` 的未访问邻居 `D` 和 `E` 加入队列尾部。
	- 队列状态：`[C, D, E]`
	- 已访问集合：`{A, B}`
4. **继续遍历**：
	- 取出队列头部 `C`，标记为已访问，加入结果列表。
	- 将 `C` 的未访问邻居 `F` 加入队列尾部。
	- 队列状态：`[D, E, F]`
	- 已访问集合：`{A, B, C}`
5. **后续层遍历**：
	- 依次取出 `D`、`E`、`F`，处理其邻居（均已访问）。
	- 最终队列清空，遍历结束。

### （4）优缺点分析

#### **1、优点**

1. **完备性**

	- **特性**：只要目标节点存在于图中，BFS 一定能找到它。
	- **应用价值**：适用于必须确保找到解的场景，如游戏中的路径规划、社交网络中的用户查找。

2. **最短路径保证**

	- **特性**：在**无权图**中，BFS 找到的路径一定是从起点到终点的最短路径（边数最少）。
	- **应用价值**：广泛用于求解最短路径问题，如迷宫寻路、网络爬虫的层级遍历。

3. **逐层遍历特性**

	- **特性**：按层次依次访问节点，适合处理需要分层处理的问题。

	- 应用价值

		：

		- 计算节点的层级（如社交网络中的 “几度关系”）。
		- 拓扑排序（在有向无环图中确定任务执行顺序）。

4. **避免深层无限循环**

	- **特性**：由于逐层扩展，不会像 DFS 那样深入某个分支导致无限循环（除非图本身存在环且未做环检测）。
	- **应用价值**：在未知结构的图中更安全，如网页爬虫避免陷入深层链接。

#### **2、缺点**

1. **空间复杂度高**
	- **问题**：最坏情况下需要存储当前层的所有节点，空间复杂度为 **O(V)**（V 为节点数）。
	- **影响**：在大规模图（如社交网络、地图导航）中，可能导致内存溢出。
	- **对比**：DFS 的空间复杂度为 **O(h)**（h 为树的高度），通常更节省空间。
2. **不适合带权图**
	- **问题**：BFS 仅考虑边的数量，不考虑边的权重。
	- **影响**：无法直接用于求解带权图中的最短路径（如 Dijkstra 算法或 A * 算法更适合）。
3. **时间效率较低**
	- **问题**：需要遍历所有可能的路径直到找到目标，时间复杂度为 **O(V + E)**（E 为边数）。
	- **对比**：在某些特定问题中（如二叉搜索树），DFS 可能更快找到目标。
4. **实现复杂度高于 DFS**
	- **问题**：需要显式维护队列结构，代码实现相对复杂。
	- **对比**：DFS 可通过递归简洁实现（但需注意栈溢出风险）。

### （5）关键

- **时间复杂度**：O (V + E)，其中 V 是节点数，E 是边数。
- **空间复杂度**：O (V)，主要用于存储队列和已访问集合。
- **最短路径**：在无权图中，BFS 找到的路径一定是最短路径。
- **队列的作用**：确保逐层访问，先进先出的顺序保证了距离起始节点近的节点先被处理。

## 四、深度优先搜索

### （1）算法原理分析

- 基本思想：
	- 从起始节点出发，沿一条路径尽可能深地访问节点，直到无法继续或达到目标节点。
	- 当无法继续时，回溯到上一个节点，尝试另一条路径。
	- 使用 ** 栈（Stack）** 来存储待访问的节点，递归实现时使用调用栈，迭代实现时使用显式栈。
- 适用场景：
	- 检测图中的环。
	- 寻找连通分量。
	- 拓扑排序。
	- 路径搜索问题。

### （2）实例

1、示例图：

```
    A
   / \
  B   C
 /|\  |
D E F |
 \|/  |
  F---|
```

节点与边的关系

- **节点 A**：连接到 B 和 C
- **节点 B**：连接到 A、D 和 E
- **节点 C**：连接到 A 和 F
- **节点 D**：仅连接到 B
- **节点 E**：连接到 B 和 F
- **节点 F**：连接到 C 和 E

2、代码

~~~ c++
def dfs_recursive(graph, start, visited=None):
    """
    深度优先搜索的递归实现
    
    参数:
    graph (dict): 图的邻接表表示
    start: 起始节点
    visited (set): 已访问节点的集合
    
    返回:
    list: 按DFS顺序访问的节点列表
    """
    if visited is None:
        visited = set()
    result = [start]
    visited.add(start)
    
    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            result += dfs_recursive(graph, neighbor, visited)
    
    return result

def dfs_iterative(graph, start):
    """
    深度优先搜索的迭代实现（使用栈）
    
    参数:
    graph (dict): 图的邻接表表示
    start: 起始节点
    
    返回:
    list: 按DFS顺序访问的节点列表
    """
    visited = set()
    stack = [start]
    result = []
    
    while stack:
        node = stack.pop()  # 弹出栈顶元素
        
        if node not in visited:
            visited.add(node)
            result.append(node)
            
            # 将邻居节点逆序压入栈，确保左子树先被访问
            for neighbor in reversed(graph.get(node, [])):
                if neighbor not in visited:
                    stack.append(neighbor)
    
    return result

# 示例图的邻接表表示
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# 从节点'A'开始进行DFS遍历
print("递归DFS遍历顺序:", dfs_recursive(graph, 'A'))
# 输出: ['A', 'B', 'D', 'E', 'F', 'C']
print("迭代DFS遍历顺序:", dfs_iterative(graph, 'A'))
# 输出: ['A', 'B', 'D', 'E', 'F', 'C']
~~~



### （3）执行步骤

1. **访问节点 A**：
	- 标记 A 为已访问，结果列表添加 A。
	- 处理 A 的邻居 B 和 C，先递归处理 B。
2. **访问节点 B**：
	- 标记 B 为已访问，结果列表添加 B。
	- 处理 B 的邻居 A、D、E，A 已访问，递归处理 D。
3. **访问节点 D**：
	- 标记 D 为已访问，结果列表添加 D。
	- D 的邻居 B 已访问，回溯到 B。
4. **继续处理 B 的邻居 E**：
	- 标记 E 为已访问，结果列表添加 E。
	- 处理 E 的邻居 B、F，B 已访问，递归处理 F。
5. **访问节点 F**：
	- 标记 F 为已访问，结果列表添加 F。
	- 处理 F 的邻居 C、E，E 已访问，递归处理 C。
6. **访问节点 C**：
	- 标记 C 为已访问，结果列表添加 C。
	- C 的邻居 A 已访问，回溯到 F，再回溯到 E、B、A，遍历结束。

**最终访问顺序：** `['A', 'B', 'D', 'E', 'F', 'C']`

### （4）优缺点分析

#### **1. 优点**

- **空间效率高**
	- **特性**：空间复杂度为 **O(h)**（h 为递归深度），远优于 BFS 的 **O(V)**。
	- **应用价值**：在大规模稀疏图中（如社交网络），DFS 能显著减少内存占用。
- **实现简洁**
	- **特性**：递归实现只需几行代码，逻辑清晰。
	- **对比**：BFS 需维护队列，代码更复杂。
- **适合路径搜索**
	- **特性**：自然适配寻找连通路径的问题（如迷宫、游戏地图）。
	- **应用**：判断两点是否连通、寻找哈密尔顿路径。
- **拓扑排序**
	- **特性**：DFS 的回溯顺序（后序遍历）可直接用于有向无环图（DAG）的拓扑排序。
	- **应用**：任务调度、编译依赖分析。
- **环检测**
	- **特性**：通过记录递归栈中的节点，可高效检测有向图中的环。
	- **应用**：依赖关系检测、死锁检测。

#### **2. 缺点**

- **不保证最短路径**
	- **问题**：DFS 可能绕远路，无法保证找到的路径是最短的。
	- **对比**：BFS 在无权图中一定能找到最短路径。
- **递归深度风险**
	- **问题**：递归实现可能导致栈溢出（Stack Overflow），尤其在深树或稠密图中。
	- **解决方案**：使用迭代实现（显式栈）或迭代加深 DFS（IDDFS）。
- **效率问题**
	- **问题**：在某些问题中（如寻找最小生成树），DFS 可能需要遍历更多节点。
	- **对比**：BFS 或贪心算法（如 Prim、Kruskal）更高效。
- **不适合分层问题**
	- **问题**：DFS 天然不适合处理需要逐层分析的问题（如社交网络中的 “层级关系”）。
	- **对比**：BFS 逐层遍历的特性更优。

### （5）关键

- **时间复杂度**：O (V + E)，其中 V 是节点数，E 是边数。
- **空间复杂度**：O (h)，其中 h 是递归的最大深度（树的高度）。
- **路径特性**：优先探索纵深路径，适合寻找连通性或特定路径。
- **递归与迭代的等价性**：递归实现简洁，但可能导致栈溢出；迭代实现使用显式栈，更安全。

## 五、四种搜索算法的比较

### **（1）基本概念**

#### **1. 线性搜索**

- **核心思想**：从序列的一端开始，逐个元素与目标值比较，直到找到匹配项或遍历完整个序列。
- **适用数据结构**：**无序数组、链表**（无需预处理）。
- **示例**：在数组 `[3, 1, 4, 2, 5]` 中查找值 `4`，从第一个元素开始比较，直到第三个元素匹配。

#### **2. 二分查找**

- **核心思想**：在**有序数组**中，每次将数组分成两半，通过比较中间元素与目标值，缩小搜索范围，直到找到目标或确定不存在。
- **适用数据结构**：**有序数组**（需先排序）。
- **示例**：在有序数组 `[1, 2, 3, 4, 5]` 中查找值 `4`，首次比较中间元素 `3`，因 `4 > 3`，在右半部分继续搜索，最终找到。

#### **3. 广度优先搜索（BFS）**

- **核心思想**：从图的起点开始，逐层遍历所有相邻节点，确保**离起点最近的节点先被访问**。使用**队列**实现（先进先出）。
- **适用场景**：**图结构**（如社交网络中的最短路径、无权图的最短路径问题）。
- **示例**：在树结构中查找根节点的所有子节点，先访问第一层节点，再访问第二层节点，以此类推。

#### **4. 深度优先搜索（DFS）**

- **核心思想**：从图的起点开始，尽可能深入遍历每条路径，直到无法继续时回溯，优先访问**同一分支的深层节点**。使用**栈**或递归实现（后进先出）。
- **适用场景**：**图结构**（如遍历所有路径、检测环、连通性分析）。
- **示例**：在树结构中查找某个叶子节点，沿着一条分支一直深入，直到到达叶子节点后回溯。

### （2）对比表

| 维度           | 线性搜索         | 二分查找 | BFS                | DFS              |
| -------------- | ---------------- | -------- | ------------------ | ---------------- |
| **数据结构**   | 无序数组 / 链表  | 有序数组 | 图 / 树            | 图 / 树          |
| **核心思想**   | 逐个遍历         | 分治思想 | 逐层扩展           | 深度优先扩展     |
| **典型应用**   | 小规模查找       | 快速定位 | 最短路径、层序遍历 | 路径遍历、环检测 |
| **时间复杂度** | O(n)             | O(log n) | O(V+E)             | O(V+E)           |
| **空间复杂度** | O(1)             | O(1)     | O(V)               | O(h)             |
| **优点**       | 简单、无需预处理 | 高效     | 适合最短路径       | 适合全路径遍历   |