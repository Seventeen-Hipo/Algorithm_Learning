# 排序

## 一、快速排序

### 样例 1

给定一个长度为n的整数数列。请你使用快速排序对这个数列按照从小到大的顺序进行排序，并将排好序的数列按顺序输出。

输入格式：

输入共两行，第一行包含整数n。

第二行包含n个整数（所有整数均在1~10^9范围内），表示整个数列。

输出格式：

输出共一行，包含n个整数，表示排好序的数列。

数据范围

1 <= n <= 100000

输入样例

~~~ c++
5
3 1 2 4 5
~~~

输出样例

~~~ c++
1 2 3 4 5
~~~

解答代码（c\c++）：

``` c++
# include<iostream>

using namespace std;

const int N = 1e6 + 10;

int n;
int q[N];
void quick_sort(int q[],int l,int r)
{
    if(l >= r)
        return;
    
    int x = q[l],i = l - 1, j = r + 1;
    while(i < j)
    {
        do i++;while(q[i] < x);
        do j++;while(q[j] > x);
        if(i < j)
            swap(q[i],q[j]);
    }
    
    quick_sort(q,l,j);
    quick_sort(q,j + 1,r)
}

int main()
{
    scanf("%d",&n);
    for(int i = 0; i < n; i++)
        scanf("%d",&q[i]);
    quick_sort(q,0,n - 1);
    for(int i = 0; i < n; i++)
        printf("%d ",q[i]);
    return 0;
}
```

1. **初始状态**：

  - 数组：`[5, 3, 1, 4, 2]`
  - 选择基准值 `x = 5`（第一个元素）
  - 左右指针初始化：`i = -1`，`j = 5`

2. **第一次分割操作**：

  - 指针移动

  	：

  	- `i` 右移至 `i = 0`（`q[0] = 5` ≥ 5）
  	- `j` 左移至 `j = 4`（`q[4] = 2` ≤ 5）

  - **交换元素**：`i < j`，交换 `q[0]` 和 `q[4]`，数组变为 `[2, 3, 1, 4, 5]`

  - 继续移动指针

  	：

  	- `i` 右移至 `i = 4`（`q[4] = 5` ≥ 5）
  	- `j` 左移至 `j = 3`（`q[3] = 4` ≤ 5）

  - **指针相遇**：`i = 4`，`j = 3`，`i > j`，分割结束

  - **最终分割点**：`j = 3`，基准值 `5` 归位，数组分为两部分：`[2, 3, 1, 4]` 和 `[5]`

3. **递归处理左子数组 `[2, 3, 1, 4]`**：

  - 选择基准值 `x = 2`

  - 左右指针初始化：`i = -1`，`j = 3`

  - 指针移动与交换

  	：

  	- `i` 右移至 `i = 0`（`q[0] = 2` ≥ 2）
  	- `j` 左移至 `j = 2`（`q[2] = 1` ≤ 2）
  	- 交换 `q[0]` 和 `q[2]`，数组变为 `[1, 3, 2, 4]`
  	- 继续移动指针：`i = 1`，`j = 1`，指针相遇

  - **分割点**：`j = 1`，基准值 `2` 归位，数组分为 `[1]` 和 `[3, 2, 4]`

  - **递归处理 `[1]`**：长度为 1，直接返回

  - 递归处理 `[3, 2, 4]`

  	：

  	- 选择基准值 `x = 3`
  	- 左右指针初始化：`i = 1`，`j = 3`
  	- 指针移动与交换：`i = 1`，`j = 2`，交换 `q[1]` 和 `q[2]`，数组变为 `[1, 2, 3, 4]`
  	- 分割点：`j = 2`，基准值 `3` 归位，数组分为 `[2]` 和 `[4]`
  	- 递归处理 `[2]` 和 `[4]`：均为长度 1，直接返回

4. **递归处理右子数组 `[5]`**：

  - 长度为 1，直接返回

5. **最终有序数组**：`[1, 2, 3, 4, 5]`

### 注意

1. **基准值选择**：
	- 代码中选择子数组的第一个元素 `q[l]` 作为基准值。
	- 这种选择简单但可能导致最坏情况（如已排序数组）。
2. **双指针初始化与移动**：
	- `i = l - 1` 和 `j = r + 1` 的初始化确保指针在移动前位于子数组边界外。
	- `do-while` 循环保证指针先移动再比较，确保元素正确划分。
3. **分割操作逻辑**：
	- 指针 `i` 找到第一个不小于基准值的元素，指针 `j` 找到第一个不大于基准值的元素。
	- 交换这两个元素，直到 `i >= j`，确保左边元素≤基准值，右边元素≥基准值。
4. **递归边界条件**：
	- 当 `l >= r` 时，子数组长度为 0 或 1，已自然有序，直接返回。
5. **递归区间划分**：
	- 以 `j` 为分界点，左子数组为 `[l, j]`，右子数组为 `[j+1, r]`。
	- 这种划分方式确保基准值最终位于正确位置，且左右子数组不重叠。

### 复杂度分析

1. **时间复杂度**：
	- **最优情况**：每次划分均匀，时间复杂度为 O (n log n)。
	- **平均情况**：接近最优，时间复杂度为 O (n log n)。
	- **最坏情况**：基准值选择不当（如已排序数组选首元素），时间复杂度为 O (n²)。
2. **空间复杂度**：
	- 递归调用栈的深度取决于划分次数，平均为 O (log n)。
	- 最坏情况下递归深度为 O (n)。
3. **稳定性**：快速排序是不稳定的排序算法，因为元素交换可能改变相同元素的相对顺序。

## 二、归并排序

### 样例1

题目描述：给定一个整数数组，使用归并排序算法对其进行排序。

输入样例：

~~~ c++
1
8
2
3 1 4 1 5 9 2 6
~~~

输出样例：

~~~ c++
1 1 2 3 4 5 6 9 
~~~

解答代码（c\c++）：

``` c++
#include <bits/stdc++.h>
 
using namespace std;
 
const int N = 1e6 + 10;  
int n;                   
int q[N], tmp[N];      
 
// 归并排序函数，对数组 q 的 [l, r] 区间进行排序
void merge_sort(int q[], int l, int r) {
    if (l >= r) return;  
 
   
    int mid = (l + r) / 2;  
    merge_sort(q, l, mid);   // 排序左半部分 [l, mid]
    merge_sort(q, mid + 1, r); // 排序右半部分 [mid+1, r]
 
    // 合并左右两个已排序的数组
    int i = l, j = mid + 1, k = 0;  // 初始化三个指针：i（左数组指针）、j（右数组指针）、k（临时数组指针）
    while (i <= mid && j <= r) {    // 同时遍历左右数组
        if (q[i] < q[j]) {         // 如果左数组元素小于右数组元素
            tmp[k++] = q[i++];     // 将左数组元素复制到临时数组，并移动指针
        } else {                   // 否则，右数组元素较小
            tmp[k++] = q[j++];     // 将右数组元素复制到临时数组，并移动指针
        }
    }
 
   
    while (i <= mid) {             // 如果左数组还有剩余元素
        tmp[k++] = q[i++];         // 将左数组元素复制到临时数组
    }
    while (j <= r) {               // 如果右数组还有剩余元素
        tmp[k++] = q[j++];         // 将右数组元素复制到临时数组
    }
 
    for (int p = l; p <= r; p++) {
        q[p] = tmp[p - l];         // 将临时数组中从 0 开始的内容复制到原数组的对应位置
    }
}
 
int main() {
    ios::sync_with_stdio(0); 
    cin.tie(0);
    cout.tie(0);
 
    cin >> n;                
    for (int i = 1; i <= n; i++) { 
        cin >> q[i];
    }
 
    merge_sort(q, 1, n); // 调用归并排序函数，对数组 q 的 [1, n] 区间进行排序
 
    for (int i = 1; i <= n; i++) {
        cout << q[i] << " ";
    }
 
    return 0;
}
```

- 以数组 `[5, 3, 1, 4, 2]` 为例，详细分析归并排序的执行过程：
	1. **初始状态**：
		- 数组：`[5, 3, 1, 4, 2]`
		- 调用 `merge_sort(q, 1, 5)`（假设数组下标从 1 开始）
	2. **递归分解阶段**：
		- 第一次分解：将数组`[5, 3, 1, 4, 2]`分为左右两部分：
			- 左子数组：`[5, 3, 1]`（索引 1-3）
			- 右子数组：`[4, 2]`（索引 4-5）
		- 递归处理左子数组 `[5, 3, 1]`：
			- 再次分解为：
				- 左子数组：`[5, 3]`（索引 1-2）
				- 右子数组：`[1]`（索引 3）
			- 处理 `[5, 3]`：
				- 分解为：
					- 左子数组：`[5]`（索引 1）
					- 右子数组：`[3]`（索引 2）
				- 递归到单个元素，无需排序，直接返回
				- 合并 `[5]` 和 `[3]` 得到 `[3, 5]`
			- **处理 `[1]`**：单个元素，直接返回
			- 合并 `[3, 5]` 和 `[1]` 得到 `[1, 3, 5]`
		- 递归处理右子数组 `[4, 2]`：
			- 分解为：
				- 左子数组：`[4]`（索引 4）
				- 右子数组：`[2]`（索引 5）
			- 递归到单个元素，无需排序，直接返回
			- 合并 `[4]` 和 `[2]` 得到 `[2, 4]`
	3. **最终合并阶段**：
		- 合并左子数组`[1, 3, 5]`和右子数组`[2, 4]`：
			- 初始化临时数组 `tmp` 和指针 `i=1`（左子数组）、`j=4`（右子数组）、`k=0`（临时数组）
			- 比较 `q[i]=1` 和 `q[j]=4`，取较小值 `1` 放入 `tmp[0]`，`i++`
			- 比较 `q[i]=3` 和 `q[j]=4`，取较小值 `3` 放入 `tmp[1]`，`i++`
			- 比较 `q[i]=5` 和 `q[j]=4`，取较小值 `4` 放入 `tmp[2]`，`j++`
			- 右子数组已遍历完，将左子数组剩余元素 `5` 放入 `tmp[3]`
			- 临时数组 `tmp` 内容为 `[1, 3, 4, 5]`，复制回原数组 `q` 的索引 1-4 位置
		- 最终有序数组：`[1, 2, 3, 4, 5]`

### 注意

1. **递归终止条件**：
	- 当 `l >= r` 时，子数组长度为 1 或 0，已自然有序，直接返回。
2. **分解过程**：
	- 通过 `mid = (l + r) / 2` 计算中点，将数组分为 `[l, mid]` 和 `[mid+1, r]` 两部分。
	- 递归调用 `merge_sort` 分别处理左右两部分。
3. **合并过程**：
	- **初始化指针**：`i` 指向左子数组起始位置 `l`，`j` 指向右子数组起始位置 `mid+1`，`k` 指向临时数组 `tmp` 的起始位置 `0`。
	- **比较元素**：循环比较 `q[i]` 和 `q[j]`，将较小的元素放入 `tmp[k]`，并移动相应指针。
	- **处理剩余元素**：若左子数组或右子数组有剩余元素，直接复制到 `tmp` 末尾。
	- **复制回原数组**：将 `tmp` 中合并后的有序元素复制回原数组 `q` 的对应位置 `[l, r]`。
4. **临时数组的作用**：
	- 合并过程中需要额外的临时数组 `tmp` 来存储中间结果，确保合并操作的稳定性。
	- 临时数组的长度至少为 `r - l + 1`，用于存储当前合并的子数组。

### 复杂度分析

1. **时间复杂度**：
	- **分解阶段**：每次递归将数组分成两半，递归深度为 **O(log n)**。
	- **合并阶段**：每层递归需要遍历所有元素一次，时间复杂度为 **O(n)**。
	- **总时间复杂度**：**O(n log n)**，无论输入数据的初始状态如何，均保持稳定性能。
2. **空间复杂度**：
	- **临时数组**：需要 **O(n)** 的额外空间存储临时合并结果。
	- **递归栈**：递归深度为 **O(log n)**，但临时数组的空间占主导，因此总空间复杂度为 **O(n)**。
3. **稳定性**：
	- 归并排序是稳定的排序算法。在合并过程中，当左右子数组元素相等时，优先选择左子数组的元素，保证相同元素的相对顺序不变。

## 三、堆排序

堆排序主要分为两个阶段：

1. **建堆（Heap Construction）**：将无序数组转化为最大堆（升序排序）或最小堆（降序排序）。
2. **排序（Heap Sorting）**：重复提取堆顶元素并调整堆，直到所有元素有序。

以数组 `[5, 3, 1, 4, 2]` 为例，详细分析堆排序的执行过程：

1. **初始状态**：

	- 数组：`[5, 3, 1, 4, 2]`

	- 对应二叉树结构（层序遍历）：

		```plaintext
		    5
		   / \
		  3   1
		 / \
		4   2
		```

1. **建堆（最大堆）**：

	- 从最后一个非叶子节点开始调整，最后一个非叶子节点索引为`n/2 - 1 = 5/2 - 1 = 1`（对应元素 3）：

		- 调整节点 3：子节点为 4 和 2，交换 3 和 4，数组变为`[5, 4, 1, 3, 2]`

			```plaintext
			    5
			   / \
			  4   1
			 / \
			3   2\
			```

		- 调整节点 5（索引 0）：子节点为 4 和 1，无需交换，数组保持 `[5, 4, 1, 3, 2]`

	- 最终最大堆：`[5, 4, 1, 3, 2]`

1. **排序过程**：

	- 第一次交换：将堆顶元素 5 与末尾元素 2 交换，得到`[2, 4, 1, 3, 5]`，此时最大元素 5 已归位。

		- 调整剩余元素`[2, 4, 1, 3]`为最大堆：

			- 调整节点 2（索引 0）：子节点为 4 和 1，交换 2 和 4，数组变为 `[4, 2, 1, 3]`

			```plaintext
			    4
			   / \
			  2   1
			 /
			3
			```

	- 第二次交换：将堆顶元素 4 与末尾元素 3 交换，得到`[3, 2, 1, 4, 5]`，此时次大元素 4 已归位。

		- 调整剩余元素`[3, 2, 1]`为最大堆：
			- 调整节点 3（索引 0）：子节点为 2 和 1，无需交换，数组保持 `[3, 2, 1]`

	- 第三次交换：将堆顶元素 3 与末尾元素 1 交换，得到`[1, 2, 3, 4, 5]`，此时元素 3 已归位。

		- 调整剩余元素`[1, 2]`为最大堆：
			- 调整节点 1（索引 0）：子节点为 2，交换 1 和 2，数组变为 `[2, 1]`

	- **第四次交换**：将堆顶元素 2 与末尾元素 1 交换，得到 `[1, 2, 3, 4, 5]`，所有元素有序。

### 代码(c\c++)

~~~ c++
#include <iostream>
using namespace std;

// 调整以i为根的子树为最大堆
void heapify(int arr[], int n, int i) {
    int largest = i;      // 初始化根节点为最大值
    int left = 2*i + 1;   // 左子节点
    int right = 2*i + 2;  // 右子节点

    // 如果左子节点比根大，则更新最大值索引
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // 如果右子节点比最大值大，则更新最大值索引
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // 如果最大值不是根节点，则交换并继续调整子树
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);  // 递归调整受影响的子树
    }
}

// 堆排序主函数
void heapSort(int arr[], int n) {
    // 建堆（从最后一个非叶子节点开始调整）
    for (int i = n/2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // 逐个提取元素
    for (int i = n-1; i > 0; i--) {
        // 将堆顶元素（最大值）与当前末尾元素交换
        swap(arr[0], arr[i]);

        // 调整剩余元素为最大堆
        heapify(arr, i, 0);
    }
}

int main() {
    int arr[] = {5, 3, 1, 4, 2};
    int n = sizeof(arr)/sizeof(arr[0]);

    heapSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;

    return 0;
}
~~~

### 复杂度分析

1. **时间复杂度**：
	- **建堆阶段**：O (n)。虽然每次调整的时间复杂度为 O (log n)，但建堆的总时间复杂度为线性级。
	- **排序阶段**：O (n log n)。每次提取堆顶元素并调整堆的时间复杂度为 O (log n)，共执行 n 次。
	- **总时间复杂度**：O (n log n)，且无论输入数据的初始状态如何，均保持稳定性能。
2. **空间复杂度**：
	- 堆排序是原地排序算法，仅需 O (1) 的额外空间。
3. **稳定性**：
	- 堆排序是不稳定的排序算法。在交换堆顶元素与末尾元素时，可能改变相同元素的相对顺序。

## 四、插入排序

以数组 `[5, 3, 1, 4, 2]` 为例，详细分析插入排序的执行过程：

1. **初始状态**：
	- 数组：`[5, 3, 1, 4, 2]`
	- 已排序部分：`[5]`
	- 未排序部分：`[3, 1, 4, 2]`
2. **第一次插入**：
	- 从未排序部分取出第一个元素 `3`
	- 与已排序部分比较：`3 < 5`，将 `5` 后移一位
	- 插入 `3` 到位置 0
	- 数组变为：`[3, 5, 1, 4, 2]`
	- 已排序部分：`[3, 5]`
	- 未排序部分：`[1, 4, 2]`
3. **第二次插入**：
	- 取出 `1`
	- 比较：`1 < 5`，后移 `5`；`1 < 3`，后移 `3`
	- 插入 `1` 到位置 0
	- 数组变为：`[1, 3, 5, 4, 2]`
	- 已排序部分：`[1, 3, 5]`
	- 未排序部分：`[4, 2]`
4. **第三次插入**：
	- 取出 `4`
	- 比较：`4 < 5`，后移 `5`；`4 > 3`，停止
	- 插入 `4` 到位置 2
	- 数组变为：`[1, 3, 4, 5, 2]`
	- 已排序部分：`[1, 3, 4, 5]`
	- 未排序部分：`[2]`
5. **第四次插入**：
	- 取出 `2`
	- 比较：`2 < 5`，后移 `5`；`2 < 4`，后移 `4`；`2 < 3`，后移 `3`；`2 > 1`，停止
	- 插入 `2` 到位置 1
	- 数组变为：`[1, 2, 3, 4, 5]`（已排序）

### 代码(c\c++)

~~~ c++
#include <iostream>
using namespace std;

void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];    // 取出未排序部分的第一个元素
        int j = i - 1;       // 已排序部分的最后一个元素索引

        // 将比key大的元素后移
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }

        // 插入key到正确位置
        arr[j + 1] = key;
    }
}

int main() {
    int arr[] = {5, 3, 1, 4, 2};
    int n = sizeof(arr) / sizeof(arr[0]);

    insertionSort(arr, n);

    cout << "Sorted array: ";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;

    return 0;
}
~~~

### 复杂度分析

1. **时间复杂度**：
	- **最好情况**：数组已有序，只需遍历一次，时间复杂度为 **O(n)**。
	- **最坏情况**：数组完全逆序，每次插入都需移动所有已排序元素，时间复杂度为 **O(n²)**。
	- **平均情况**：**O(n²)**，适用于小规模数据。
2. **空间复杂度**：
	- 原地排序，仅需 **O(1)** 的额外空间。
3. **稳定性**：
	- 插入排序是稳定的排序算法，因为相等元素不会被交换位置。

## 五、各种排序算法的比较

| **排序算法** | **执行思路**                                                 | **时间复杂度**   | **空间复杂度** | **稳定性** | **适用场景**                   |
| ------------ | ------------------------------------------------------------ | ---------------- | -------------- | ---------- | ------------------------------ |
| **冒泡排序** | 相邻元素比较，逆序时交换，每轮确定最大 / 最小值位置。        | O(n²)            | O(1)           | 稳定       | 小规模数据或基本有序数据       |
| **插入排序** | 将元素插入已排序区间的合适位置，类似打牌时整理手牌。         | O(n²)            | O(1)           | 稳定       | 小规模数据或部分有序数据       |
| **选择排序** | 每轮选择未排序区间的最小 / 最大值，交换到已排序区间末尾。    | O(n²)            | O(1)           | 不稳定     | 不推荐大规模数据，简单场景适用 |
| **归并排序** | 分治思想，递归分割数组为两半，分别排序后合并（需临时空间）。 | O(n log n)       | O(n)           | 稳定       | 大规模数据，要求稳定性的场景   |
| **快速排序** | 分治思想，选基准值分区，递归排序左右子数组（原地排序，无需额外空间）。 | 平均 O (n log n) | O(log n)~O(n)  | 不稳定     | 大规模数据，通用排序场景       |
| **堆排序**   | 构建大根堆 / 小根堆，每次取出堆顶元素，重新调整堆结构。      | O(n log n)       | O(1)           | 不稳定     | 大规模数据，无需稳定性的场景   |
